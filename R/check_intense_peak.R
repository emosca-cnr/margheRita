#' check the ppm error for the intense peaks
#'
#'
#' @export
#'
#' @param RT_mass it is a list of data frame, obtained by check_RT_mass() function. it is contains a list of metabolite with desired retention time and PPM error. each metabolite is a data frame of potential candidates with specific features; Feature_ID, RT_err, RT_flag, ppm_error, mass_status and mass_flag.
#' @param RI_lib it is generated by RI_lib_data() or select_library() function in order to turn intensity to relative intensity and filter the spectra by deleting the low intense peaks. note that in house library of the margheRita is already stored by relative intensity and filtered by select_library() function so, in this case RI_lib is lib_peaks which is generated by select_library() function.
#' @param RI_sample it is generated by RI_sample_data() function in order to turn intensity to relative intensity and filter the spectra by deleting the low intense peaks.
#' @param reference A list of metabolite with their specific features of retention time and mz which stored by their ID, CAS number and Name.
#' @param lib_peaks_data it is generated by select_library() function. it is providing information regarding the peaks such as ID, CAS number, Name and POS/NEG collision energy.
#' @param n_peaks A number with default value of 1. check_intense_peak() function calculate the PPM error peak by peak starting from the most intense one. n_peaks is the number of the peaks which will be calculated for each metabolite and candidate.
#' @param acceptable_PPM_err A number with default value of 10. The maximum PPM error must be less than this value. and those above this number will be eliminated.
#' @param mode mode could be set in positive or negative state. positive mode select positive collision energy and mz in positive mode.
#'
check_intense_peak = function(RT_mass=NULL, RI_lib=NULL , RI_sample=NULL, reference=NULL, lib_peaks_data=NULL, n_peaks=1, acceptable_PPM_err = 10, mode=c("POS", "NEG")) {

  #a novel data to not touch the input
  ans <- vector("list", length(RT_mass))
  names(ans) <- names(RT_mass)

  #ensure the same order
  lib_peaks_data <- lib_peaks_data[match(names(RI_lib), lib_peaks_data$ID), ]

  #z cycles trhough the precursor library entries
  for(z in 1:length(RT_mass)){

    #clean the library to keep only metabolites that appear in the sample
    CAS_z <- reference$CAS[reference$ID == names(RT_mass)[z]]
    z_peaks_all <- RI_lib[lib_peaks_data$CAS == CAS_z & lib_peaks_data$Collision_energy == mode ]

    if(length(z_peaks_all)>0){
      #cycle thourgh the peaks that are available for the given CAS at precursor level
      for(zzzz in 1:length(z_peaks_all)){
        z_peaks <- z_peaks_all[[zzzz]]

        #cycle thourgh the candidates
        for(zi in 1:nrow(RT_mass[[z]])){
          zi_peaks <- as.data.frame(RI_sample[names(RI_sample) == RT_mass[[z]]$Feature_ID[zi]])

          table_values_a <- sort(unique(z_peaks[, 2]), decreasing = T) #library peaks
          table_values_b <- sort(unique(zi_peaks[, 2]), decreasing = T) #sample peaks

          temp_flag_peaks <- rep(FALSE, n_peaks)
          for(ii in 1:min(n_peaks, length(table_values_a))){

            a = z_peaks[z_peaks[,2] == table_values_a[ii], , drop=FALSE]
            if(length(table_values_b) < ii){
              break
            }
            b = zi_peaks[zi_peaks[,2] == table_values_b[ii], , drop=FALSE]

            PPM_err <- calc_ppm_err(a, b)
            temp_flag_peaks[ii] <- any(PPM_err < acceptable_PPM_err)

            if(!temp_flag_peaks[ii]){ #if FALSE avoid the comparison for the next peaks
              break
            }

          }

          #add information about the peak to the precursor
          if(is.null(ans[[z]])){
            ans[[z]] <- data.frame(Feature_ID=RT_mass[[z]]$Feature_ID[zi], ID_peaks=names(z_peaks_all)[zzzz], intense_peaks=all(temp_flag_peaks), stringsAsFactors = F)
          }else{
            ans[[z]] <- rbind(ans[[z]], data.frame(Feature_ID=RT_mass[[z]]$Feature_ID[zi], ID_peaks=names(z_peaks_all)[zzzz], intense_peaks=all(temp_flag_peaks), stringsAsFactors = F))

          }

        } #end cycle through candidates

      } #end cycle through the peaks for that CAS

    }

    if(!is.null(ans[[z]])){
      #keep only peaks with TRUE flags
      ans[[z]] <- merge(RT_mass[[z]], ans[[z]], by="Feature_ID", sort=F)
      ans[[z]] <- data.frame(ID=names(ans)[z], ans[[z]], stringsAsFactors=F)
    }

  }

  #filter the RT_mass by deleting the empty data.frame;
  ans <- ans[sapply(ans, function(x) !is.null(x))]

  if(length(ans)>0){
    ans <- lapply(ans, function(x) x[x$intense_peaks, ])
  }else{
    message("none of the candidates matches the library peaks with current parameters\n")
    return()
  }

  if(length(ans)>0){
    ans <- ans[sapply(ans, function(x) nrow(x)>0)]

  }else{
    message("none of the candidates matches the library peaks with current parameters\n")
    return()
  }

  if(length(ans)>0){
    ans <- do.call(rbind, ans)
    ans <- merge(ans, lib_peaks_data, by.x="ID_peaks", by.y="ID", all.x=T)
    colnames(ans)[colnames(ans) == "Name"] <- "Name_peaks"
    ans <- merge(reference, ans, by=c("ID", "CAS"), all.y=T)
    ans <- ans[, c("Feature_ID", "ID", "CAS", "PubChemCID", "Name", "rt", "RT_err", "RT_flag", "mz", "ppm_error", "mass_status", "mass_flag", "ID_peaks", "Name_peaks", "intense_peaks", "Collision_energy")]
  }else{
    message("none of the candidates matches the library peaks with current parameters\n")
    return()
  }

  return(ans)

}

