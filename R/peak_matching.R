#' Peak matching for metabolite families
#'
#' @export
#' @param reference an object structured as the element "lib_precursor" of the list returned by margherita_library()
#' @param RI_lib it is generated by RI_lib_data() or select_library() function in order to turn intensity to relative intensity and filter the spectra by deleting the low intense peaks. note that in house library of the margheRita is already stored by relative intensity and filtered by select_library() function so, in this case RI_lib is lib_peaks which is generated by select_library() function.
#' @param RI_sample it is generated by RI_sample_data() function in order to turn intensity to relative intensity and filter the spectra by deleting the low intense peaks.
#' @param lib_peaks_data it is generated by select_library() function. it is providing information regarding the peaks such as ID, CAS number, Name and POS/NEG collision energy.
#' @param mode mode could be set in positive or negative state. positive mode select positive collision energy and mz in positive mode.
#' @param ppm_err A number with default value of 10. The maximum PPM error must be less than this value. and those above this number will be eliminated.
#' @param intensity maximum relative intensity
#' @param RT_mass a list of data frame, obtained by check_RT_mass() function. it is contains a list of metabolite with desired retention time and PPM error. each metabolite is a data frame of potential candidates with specific features; Feature_ID, RT_err, RT_flag, ppm_error, mass_status and mass_flag.


peak_matching = function(reference=NULL, RT_mass=NULL, RI_lib=NULL, RI_sample=NULL,  lib_peaks_data=NULL, mode=c("POS", "NEG"), ppm_err=10, intensity=30) {

  #a novel data to not touch the input
  ans <- vector("list", length(RT_mass))
  names(ans) <- names(RT_mass)

  #store the matrices of peak-peak comparison
  ans2 <- ans
    
  #ensure the same order
  lib_peaks_data <- lib_peaks_data[match(names(RI_lib), lib_peaks_data$ID), ]

  #cycle through every library element of RT_mass 
  for(z in 1:length(RT_mass)){
    
    ### add columns with number of peaks found and library element
    #RT_mass[[z]]$peaks_found_ppm_RI <- 0 #removed... see below
    RT_mass[[z]]$ID <- names(RT_mass)[z]

    ### CAS number of the library element
    CAS_z <- reference$CAS[reference$ID == names(RT_mass)[z]]
    
    ##the list of the MS/MS spectra for the library element (it can be not unique)
    z_peaks_all <- RI_lib[lib_peaks_data$CAS == CAS_z & lib_peaks_data$Collision_energy == mode ]

    if(length(z_peaks_all)>0){

      ans2[[z]] <- z_peaks_all
      
      #cycle through the MS/MS spectra
      for(zzzz in 1:length(z_peaks_all)){
        
        #one of the MS/MS spectra
        z_peaks <- as.data.frame(z_peaks_all[[zzzz]])

        #RT_mass[[z]]$ID_peaks <- names(z_peaks_all)[zzzz]

        ans2[[z]][[zzzz]] <- vector("list", nrow(RT_mass[[z]]))
        names(ans2[[z]][[zzzz]]) <- RT_mass[[z]]$Feature_ID
        #cycle through the features assigned to the library element
        for(zi in 1:nrow(RT_mass[[z]])){
          
          #the MS/MS spectra of the feature
          zi_peaks <- as.data.frame(RI_sample[names(RI_sample) == RT_mass[[z]]$Feature_ID[zi]])

          ###pmm error matrix and flags: library_peaks-by-feature_peaks
          pmm_error_matrix <- matrix(0, nrow(z_peaks), nrow(zi_peaks))
          pmm_error_matrix_flags <- pmm_error_matrix

          ###RI error matrix and flags: library_peaks-by-feature_peaks
          RI <- pmm_error_matrix
          RI_flags <- pmm_error_matrix

          ### cycle throug all pairs of peaks
          for(i in 1:nrow(pmm_error_matrix)){
            for(j in 1:ncol(pmm_error_matrix)){
              
              ###ppm error of the peak pair i,j
              pmm_error_matrix[i, j] = abs(z_peaks[i, 1] - zi_peaks[j, 1]) / z_peaks[i, 1] * 1000000
              
              ###RI diff of the peak pair i,j
              RI[i, j] = abs(z_peaks[i, 2] - zi_peaks[j, 2])
            }
          }

          #count the peaks that are found
          pmm_error_matrix_flags[pmm_error_matrix < ppm_err] <- 1 ##peaks matching
          RI_flags[RI < intensity] <- 2 ##RI matching

          #peaks and RI
          flags_matrix <- pmm_error_matrix_flags + RI_flags

          #store the number of peaks matching, this will be over written in case a different number of matches is found for z,zi but different zzzz;
          #UPDATE save peaks_found_ppm_RI in ans
          #RT_mass[[z]]$peaks_found_ppm_RI[zi] <- sum(sign(rowSums(flags_matrix==3))) 
          n_matched_peaks <- sum(sign(rowSums(flags_matrix==3))) 


          ans2[[z]][[zzzz]][[zi]] <- list(
            ppm_error = pmm_error_matrix,
            ppm_error_flags = pmm_error_matrix_flags,
            RI_diff=RI,
            RI_diff_flags=RI_flags,
            flags=flags_matrix,
            n=n_matched_peaks
          )
          
          #save current result for library element z, feature zi, library MS/MS spectra zzzz
          if(is.null(ans[[z]])){
            ans[[z]] <- data.frame(Feature_ID=RT_mass[[z]]$Feature_ID[zi], ID_peaks=names(z_peaks_all)[zzzz], peaks_found_ppm_RI=n_matched_peaks, stringsAsFactors = F)
          }else{
            ans[[z]] <- rbind(ans[[z]], data.frame(Feature_ID=RT_mass[[z]]$Feature_ID[zi], ID_peaks=names(z_peaks_all)[zzzz], peaks_found_ppm_RI=n_matched_peaks, stringsAsFactors = F))
          }

        } #END cycle through the features assigned to the library element

      } #END cycle through the MS/MS spectra of library
    }
    
    ### merge RT_mass of the library element with ans by Feature_ID, add reference info
    if(!is.null(ans[[z]])){
      #keep only peaks with TRUE flags
      #ans[[z]] <- merge(RT_mass[[z]], ans[[z]], by="Feature_ID", sort=F, no.dups = TRUE, all.y=FALSE) ###all.y is false by default
      ans[[z]] <- merge(RT_mass[[z]], ans[[z]], by="Feature_ID", sort=F, no.dups = TRUE)
      ans[[z]] <- merge(ans[[z]], reference, by="ID")
    }

  }

  #filter the ans by deleting the empty data.frame;
  ans <- ans[sapply(ans, function(x) !is.null(x))]

  #filter the ans by deleting the candidates without matches
  for (k in 1:length(ans)) {
    ans[[k]] <- ans[[k]][ans[[k]]$peaks_found_ppm_RI != 0, ]
  }

  #filter the ans by deleting the empty data.frame
  ans <- ans[sapply(ans, function(x) dim(x)[1]) > 0]
  ans <- do.call(rbind, ans)

  return(list(matched_peaks=ans, matrices=ans2))

}
