#' MS/MS peaks matching
#'
#' @export
#' @param library_list an object structured as the element "lib_precursor" of the list returned by select_library()
#' @param RI_sample it is generated by calc_RI() function in order to turn intensity to relative intensity and filter the spectra by deleting the low intense peaks.
#' @param ppm_err A number with default value of 10. The maximum PPM error must be less than this value. and those above this number will be eliminated.
#' @param intensity maximum relative intensity
#' @param library_matched_features a list of data frame, obtained by check_RT_mass() function. it is contains a list of metabolite with desired retention time and PPM error. each metabolite is a data frame of potential candidates with specific features; Feature_ID, RT_err, RT_flag, ppm_error, mass_status and mass_flag.
#' @param RI_diff_type type of relative intensity difference: absolute or relative
#' @return A list with a data.frame of matched_peaks and matrices with scores of all-pairs comparison between peaks


peak_matching <- function(library_list=NULL, library_matched_features=NULL, RI_sample=NULL, ppm_err=20, intensity=20, RI_diff_type=c("rel", "abs")) {
  
  #a novel data to not touch the input
  if(is.null(library_matched_features)){
    cat("No library_matched_features, checking all MS/MS in library againts all features in sample.\n")
    
    #create an library_matched_features with all Feature_ID for all library elment
    library_matched_features <- setNames(vector("list", nrow(library_list$lib_precursor)), library_list$lib_precursor$ID)
    library_matched_features <- lapply(library_matched_features, function(i_element) data.frame(Feature_ID=names(RI_sample), stringsAsFactors = F))
    
  }
  
  #check that all features in library_matched_features are available in RI_sample
  features_input_matched  <- unlist(lapply(library_matched_features, function(x) x$Feature_ID))
  if(!all(features_input_matched %in% names(RI_sample))){
    cat("features:", features_input_matched[!features_input_matched %in% names(RI_sample)], "\n")
    stop("some features in library_matched_features do not appear in RI_sample.\n")
  }
  
  
  ans <- vector("list", length(library_matched_features))
  names(ans) <- names(library_matched_features)
  
  #store the matrices of peak-peak comparison
  ans2 <- ans
  
  
  RI_diff_type <- match.arg(RI_diff_type)
  if(RI_diff_type=="rel"){
    RI_diff_type <- 1
  }else{
    RI_diff_type <- 0
  }
  
  
  #ensure the same order
  library_list$lib_peaks_data <- library_list$lib_peaks_data[match(names(library_list$lib_peaks), library_list$lib_peaks_data$ID), ]
  
  #cycle through every library element of library_matched_features
  cat("\t# library metabolites to consider: ", length(library_matched_features), "\n")
  for(z in 1:length(library_matched_features)){
    
    if(z %% 100 == 0){
      cat("\t", z, "/", length(library_matched_features), "\n")
    }
    
    ### add columns with library Name of the current ID
    #library_matched_features[[z]]$peaks_found_ppm_RI <- 0 #removed... see below
    library_matched_features[[z]]$ID <- names(library_matched_features)[z]
    
    ### CAS number of the library element
    #CAS_z <- library_list$lib_precursor$CAS[library_list$lib_precursor$ID == names(library_matched_features)[z]]
    key_field_z <- library_list$lib_precursor[library_list$lib_precursor$ID == names(library_matched_features)[z], library_list$key_field]
    
    ### mz of the library element (precursor)
    mz_precursor <- library_list$lib_precursor$mz[library_list$lib_precursor$ID == names(library_matched_features)[z]]
    
    ##the list of the MS/MS spectra for the library element (it can be not unique)
    #z_peaks_all <- RI_lib[library_list$lib_peaks_data$CAS == CAS_z & library_list$lib_peaks_data$Collision_energy == mode ]
    z_peaks_all <- library_list$lib_peaks[library_list$lib_peaks_data[, library_list$key_field] == key_field_z]
    
    if(length(z_peaks_all)>0){
      
      ans2[[z]] <- z_peaks_all
      
      #cycle through the MS/MS spectra
      for(zzzz in 1:length(z_peaks_all)){
        
        #one of the MS/MS spectra
        z_peaks <- as.data.frame(z_peaks_all[[zzzz]])
        
        #library_matched_features[[z]]$ID_peaks <- names(z_peaks_all)[zzzz]
        
        ans2[[z]][[zzzz]] <- vector("list", nrow(library_matched_features[[z]]))
        names(ans2[[z]][[zzzz]]) <- library_matched_features[[z]]$Feature_ID
        
        #cycle through the features assigned to the library element
        for(zi in 1:nrow(library_matched_features[[z]])){
          
          #the MS/MS spectra of the feature
          zi_peaks <- as.data.frame(RI_sample[names(RI_sample) == library_matched_features[[z]]$Feature_ID[zi]])
          
          #presence of the precursor in the MS/MS specra
          precursor_feature_peaks_ppmerror <- abs(mz_precursor - zi_peaks[, 1]) / mz_precursor * 1000000
          precursor_feature_peaks_ppmerror <- any(precursor_feature_peaks_ppmerror < ppm_err)
          
          ###pmm error matrix and flags: library_peaks-by-feature_peaks
          pmm_error_matrix <- matrix(0, nrow(z_peaks), nrow(zi_peaks))
          pmm_error_matrix_flags <- pmm_error_matrix
          
          ###RI error matrix and flags: library_peaks-by-feature_peaks
          RI <- pmm_error_matrix
          RI_flags <- pmm_error_matrix
          
          ### cycle throug all pairs of peaks
          for(i in 1:nrow(pmm_error_matrix)){
            for(j in 1:ncol(pmm_error_matrix)){
              
              ###ppm error of the peak pair i,j
              pmm_error_matrix[i, j] = abs(z_peaks[i, 1] - zi_peaks[j, 1]) / z_peaks[i, 1] * 1000000
              
              ###RI diff of the peak pair i,j
              #abs difference, RI_diff_type==0: RI_den -> RI_perc -> 1
              #relative difference, RI_diff_type==1: RI_den -> z_peaks[i, 2] and RI_perc -> 100
              RI_den <- 1 - RI_diff_type + z_peaks[i, 2] * RI_diff_type
              RI_perc <- 1 - RI_diff_type + 100 * RI_diff_type
              RI[i, j] = abs(z_peaks[i, 2] - zi_peaks[j, 2]) / RI_den * RI_perc
            }
          }
          
          #count the peaks that are found
          pmm_error_matrix_flags[pmm_error_matrix < ppm_err] <- 1 ##peaks matching
          RI_flags[RI <= intensity] <- 2 ##RI matching
          
          #peaks and RI
          flags_matrix <- pmm_error_matrix_flags + RI_flags
          
          #store the number of peaks matching, this will be over written in case a different number of matches is found for z,zi but different zzzz;
          #UPDATE save peaks_found_ppm_RI in ans
          #library_matched_features[[z]]$peaks_found_ppm_RI[zi] <- sum(sign(rowSums(flags_matrix==3))) 
          n_matched_peaks <- sum(sign(rowSums(flags_matrix==3)))
          ratio_matched_peaks <- n_matched_peaks / nrow(flags_matrix)
          
          
          ans2[[z]][[zzzz]][[zi]] <- list(
            ppm_error = pmm_error_matrix,
            ppm_error_flags = pmm_error_matrix_flags,
            RI_diff=RI,
            RI_diff_flags=RI_flags,
            flags=flags_matrix,
            n=n_matched_peaks,
            n_ratio=ratio_matched_peaks
          )
          
          #save current result for library element z, feature zi, library MS/MS spectra zzzz
          if(is.null(ans[[z]])){
            ans[[z]] <- data.frame(Feature_ID=library_matched_features[[z]]$Feature_ID[zi], ID_peaks=names(z_peaks_all)[zzzz], peaks_found_ppm_RI=n_matched_peaks, matched_peaks_ratio=ratio_matched_peaks, precursor_in_MSMS=precursor_feature_peaks_ppmerror, stringsAsFactors = F)
          }else{
            ans[[z]] <- rbind(ans[[z]], data.frame(Feature_ID=library_matched_features[[z]]$Feature_ID[zi], ID_peaks=names(z_peaks_all)[zzzz], peaks_found_ppm_RI=n_matched_peaks, matched_peaks_ratio=ratio_matched_peaks, precursor_in_MSMS=precursor_feature_peaks_ppmerror, stringsAsFactors = F))
          }
          
        } #END cycle through the features assigned to the library element
        
      } #END cycle through the MS/MS spectra of library
    }
    
    ### merge library_matched_features of the library element with ans by Feature_ID, add library_list$lib_precursor info
    if(!is.null(ans[[z]])){
      #keep only peaks with TRUE flags
      #ans[[z]] <- merge(library_matched_features[[z]], ans[[z]], by="Feature_ID", sort=F, no.dups = TRUE, all.y=FALSE) ###all.y is false by default
      ans[[z]] <- merge(library_matched_features[[z]], ans[[z]], by="Feature_ID", sort=F)
      ans[[z]] <- merge(ans[[z]], library_list$lib_precursor, by="ID", suffixes=c("", "_lib"), all.x=TRUE, sort=F)
    }
    
  } #END cycle through every element of the library
  
  #filter the ans by deleting the empty data.frame;
  ans <- ans[sapply(ans, function(x) !is.null(x))]
  
  #filter the ans by deleting the candidates without matches
  for (k in 1:length(ans)) {
    ans[[k]] <- ans[[k]][ans[[k]]$peaks_found_ppm_RI != 0, ]
  }
  
  #filter the ans by deleting the empty data.frame
  ans <- ans[sapply(ans, function(x) dim(x)[1]) > 0]
  ans <- do.call(rbind, ans)
  
  return(list(matched_peaks=ans, matrices=ans2))
  
}
