---
title: "margheRita - an R package for analyzing the entire workflow of mass spectrometry-based metabolic profiles"
author:
- name: Maria Ulaszewska
  affiliation: ProMeFa, Proteomics and Metabolomics Facility, Center for Omics Sciences (COSR), IRCCS San Raffaele Scientific Institute, Milan 20132, Italy
- name: Edoardo Bellini
  affiliation: Center for Omics Sciences (COSR), IRCCS San Raffaele Scientific Institute, Milan 20132, Italy
- name: Denise Drago
  affiliation: ProMeFa, Proteomics and Metabolomics Facility, Center for Omics Sciences (COSR), IRCCS San Raffaele Scientific Institute, Milan 20132, Italy
- name: Valeria Mannella
  affiliation: Center for Omics Sciences (COSR), IRCCS San Raffaele Scientific Institute, Milan 20132, Italy
- name: Zahrasadat Alavikakhki
  affiliation: University of Milan, Milan, Italy
- name: Marco Morelli
  affiliation: Center for Omics Sciences (COSR), IRCCS San Raffaele Scientific Institute, Milan 20132, Italy
- name: Annapaola Andolfo
  affiliation: ProMeFa, Proteomics and Metabolomics Facility, Center for Omics Sciences (COSR), IRCCS San Raffaele Scientific Institute, Milan 20132, Italy
- name: Ettore Mosca
  affiliation: National Research Council, Institute of Biomedical Technologies, Segrate (Milan), Italy
abstract: >
  MargheRita is intended for any kind of mass spectrometer raw data, including both $MS$ and $MS/MS$ data. It takes as input `.txt/.csv`or `.xlsx` files that contain the metabolic profiles generated by **[MS-Dial](http://prime.psc.riken.jp/compms/msdial/main.html)** and metadata for sample processing. The first pre-processing step performs the integration of the metabolic profiles in a unique data structure and generates plots for quality control about outliers, drifts or batch effects. Then, metabolites and samples can be filtered based on the quantification of mass defect values, missing values and coefficient of variation of m/z features along QC and study samples. Moreover, margheRita provides various methods for missing value imputation and data normalization, including those particular recommended for metabolomic profiles, like the Probabilistic Quotient Normalization (PQN) or the normalization to a standard factor (e.g. protein concentration, urine osmolality). Subsequent analyses include: parametric and non-parametric statistical tests for the identification of significant metabolite signatures; sample clustering; metabolite correlation analysis and pathway analysis (using databases like **[KEGG](https://www.genome.jp/kegg/)** and **[Biocyc](https://biocyc.org)**). Additional advantage derives from the $MS/MS$ data management and annotations with the possibility of data browsing and searching.
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{margheRita - an R package for analyzing the entire workflow of mass spectrometry-based metabolic profiles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Getting started

![](images/logo.png){width=60%}

The package can be installed using devtools:
```{r, eval=FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}
devtools::install_github("emosca-cnr/margheRita", dependencies = T)
```

# Reading input files

The function `read_input_file()` allows you to import the dataset and its relative metadata creating margheRita object "mRList", other parameters that can be specified are:

* `split_QC`: Boolean, whether to split QC samples from the others or not (default: TRUE).

* `rt_col`: integer parameter, it specifies the number of the column that corresponds to retention time.

* `mz_col`: the same for `rt_col`, but for the $m/z$ corresponding column

* `data_start_col`: integer parameter that specifies the number of the column

* type of files : users have to specify if input data are in excel(.xlsx), csv or txt format, type=c("excel","csv","text")

Currently margheRita includes two datasets. To load the first one, "example1", run:
```{r, eval=FALSE}
input_data_file <- system.file("extdata", "example1.xlsx", package = "margheRita")
input_metadata_file <- system.file("extdata", "example1_meta.xlsx", package = "margheRita")
mRList <- read_input_file(input = input_data_file, metadata = input_metadata_file, split_QC = TRUE, rt_col = 2, mz_col =3 , data_start_col = 4)
```
To load the second, a dataset where metabolite intensities show a drift related to injection order, run:
```{r, eval=FALSE}
input_data_file <- system.file("extdata", "dataset_drift.xlsx", package = "margheRita")
input_metadata_file <- system.file("extdata", "dataset_drift_metadata.xlsx", package = "margheRita")
mRList <- read_input_file(input_data_file, metadata = input_metadata_file, data_start_col = 8, rt_col = 2, mz_col = 3)
```
 

The mRList object has this structure:

Objects in mRList  | Description
------------- | -------------
data  | matrix containing metabolite intesity
metab_ann  | metabolite annotation
sample_ann | sample annotation
QC | matrix containing metabolite intesity for QC
QC_ann | QC annotation

Importantly, the mRList can be translated into `metaboset` or `MSnSet` classes:
```{r, eval=FALSE}
mset <- as.metaboset.mRList(mRlist)
msnset <- as.MSnSet.mRList(mRlist)
```

# Preprocessing

margheRita provides filters on the basis of $m/z$ and missing values:

```{r, eval=FALSE}
mRList_filt <- m_z_filtering(m_list = mRlist, lower_quality_mass_acc = 0.4, upper_quality_mass_acc = 0.8, do_plot = T, color="black")
mRList_filt <- filter_NA(mRList_filt)

```

* `m_list`: mRlist object.

* `lower_quality_mass_acc`: floating parameter, it specifies the lower number associated to the firt $m/z$ feature decimal number that will be cut off.

* `upper_quality_mass_acc`: floating parameter, it specifies the upper number associated to the firt $m/z$ feature decimal number that will be cut off.

* `do_plot`: Boolean parameter that specifies if a distribution plot of $m/z$ feature has to be displayed

* `color`: character specifying the color of the curve. 

<!-- function output produce in metab_ann a column called quality: 
```{r, eval=FALSE}
head(m_list$metab_ann, 5)
```
-->

## Imputation missing value

Imputation function provides to impute missing value of each feature replacing a random number between 10% and 25% of the minimum value of the feature. 

## Heatscatter Cromatography

This function provide an overview of all the $m/z$ features in all experiments during all the chromatogram, by generating a Heatscatter plot using `LSD::heatscatter()` function exploiting *LSD* package (https://cran.r-project.org/web/packages/LSD/index.html)
```{r, eval=FALSE}
heatscatter_chromatography(mRList, mz_limits = NULL, rt_limits = NULL, sample = NULL)
```
* `sample`: character parameter, default value is `NULL`, if specified in the plot will be provided only $m/z$ feature present in that specific sample.

* `mz_limits`: vector parameter, default value is `NULL`, that specifies the minimum and maximum value of the $m/z$ features window that have to be displayed.

* `rt_limits`: vector parameter, default value is `NULL`, that specifies the minimum and maximum value of the retention time window that have to be displayed.

![](images/hetascatter.png){width=100%}

## Batch effect correction

batch_effect function remove batch effect correction using *limma* package. Batch is indicated in the column of metadata by number.

## Collapse technical replicates

The collapse_tech_rep function calculates the mean of the technical replicates for each biological replicate. The outputs are data and metadata without technical replicates but with biological replicates only. 
```{r,eval=FALSE}
mRList<-collapse_tech_rep(mRList, remove.QC=FALSE)
```

## Principal Component Analysis

pca_gen function allows to perform Principal Component Analysis (PCA). Specific parameters are:

* `include_QC` = if quality control (QC) samples have to be added in the PCA analysis, data have to be split in read_input_file function (as default) and they are not to be collapsed. Default =TRUE (QCs are considered). 
* `scaling` = different types of scaling can be chosen by user: Pareto, UV or none. Users have to specify the type of scaling.
* `write_output`= if tables, as .csv format, have to be saved. Default=FALSE
* `col_by` = define how to color the samples: by class, timepoint, etc.

```{r , eval=F}
pca_gen(mRList, col_by = "class")
```
![Scoreplot of the first two components](images/Scoreplot.png){width=60%}


## Normalization
Currently, margheRita provides three ways for normalizing metabolite profiles:

* `log`: log2-normalization;

* `reference`: every sample is divided by a reference value;

* `pqn`: probabilistic quotient normalization.

Here's the code for using PQN:

```{r, eval=FALSE}
mRList <- calc_reference(mRList)
mRList_norm <- normalize_profiles(mRList, method = "pqn")
```


## Filter by coefficient of variation

CV function calculates the coefficient of variation for each metabolite for samples and QC, separately, to assess the precision and repeatability of the measurement. 
CV is calculated using the following equation:
     $CV= (stdev/mean)*100$.
If $CV QC > CV sample$ metabolite is deleted. 

```{r, eval=FALSE}
mRList<-CV(mRList)

```


# Univariate analysis

## Descriptive statistics: mean, median and standard deviation

mean_median_stdev_samples function allows to retrieve principal descriptive statistics indexes for all $m/z$ features. The function retrieves for all features across all different groups the intensities mean, median and standard deviation. Results were reported in metab_ann.
If tables have to be saved,as .csv files, write_output=TRUE. Default write_output=FALSE.

```{r, eval=FALSE}
mRList <- mean_median_stdev_samples(mRList, write_output = F)
```

## Differential intensity analysis

Differential intensity analysis works on collapsed data: data frame has to contain only biological replicates. Use collapse_tech_rep function to collapse technical replicates.
Results were reported in metab_ann.
margheRita implements differential abundance analysis by using the fold change index: $log_2(\frac{\bar{B}}{\bar{A}})$ where $\bar{B}$ and $\bar{A}$ are the second and the first term of the specified contrast,respectively. Within margheRita regarding this context are implemented two functions:
```{r, eval=FALSE}
mRList <- calculate_lfc_all(mRList = mRList, lfc_theshold = 0.25)
```
This function allow to perform for all $m/z$ feature the fold change, among all useful pairwise comparisons, the specifiable parameters of the function are:
* `lfc_theshold`: an integer representing the fold change upper which the corresponding negative value and lower which the corresponding positive value, a $m/z$ is considered significative or not, (so for example if a user specifies `lfc_theshold=0.25` all $-0.25<log_2(Fold Change)>+0.25$ are consider not significative and the function assign value 0).
If the user is interest to a specific contrast a second function in witch you can specify was constructed:
```{r, eval=F}
mRList <- calculate_lfc(mRList = mRList, lfc_theshold = 0.25, contrast_samples = c("BAL_STAND", "NOD_STAND"))

```
* `contrast_samples`: is a character vector of samples specified in the metadata.


## Check normal distribution of metabolites

norm_check function uses Shapiro-wilk's test to check the normality of each metabolite. The output is a list of p-values for each metabolite. If p-value<0.05 metabolite is not normally distributed, if p-value>0.05 metabolite is normally distributed.

```{r, eval=FALSE}
mRList$shapirotest<-norm_check(mRList)

```

## Statistical tests (Student t test, Wilcoxon, Kruskal, Anova)

Univariate allows to perform univariate analysis on collapsed data. In case of data frame with technical replicates collapse_tech_rep function has to be used. 
User has to choose different kind of statistical test to apply to data: Student t-test, Wilcoxon test, anova or kruskal.

```{r, eval=FALSE}
univariate <- function(mRList, dirout="./", test_method=c("ttest", "anova", "Utest", "kruskal"), paired=c("FALSE", "TRUE"), group_factor="class")
```


# Metabolite identification

Metabolite identification is based on a level-1 library containing about 800 metabolites spanning several biological functions. The identification follows these steps:

* precursor RT;

* precursor ppm error;

* ppm errors of ions;

* relative intensity of ions.


## Generate dataset for metabolite annotation 

Mass spectrometry provides us variety of information but, metabolite annotation needs only four set of data called feature data and reference including retention time (RT) and m/z and spectra of the feature and reference. 
`annotation_dataset()` function generate required data. 


## Metabolite annotation function 

metabolites_annotation function uses the four dataset and default values for retention time (RT) threshold, range of acceptable and unacceptable PPM error, acceptable relative intensity in order to have a clean dataset and number of the most intensive peaks which are calculated for acceptable PPM error. All these values are modifiable based on the specificity and goal of the study. 

```{r, eval=FALSE}
metabolites_annotation = metabolite_annotation(feature_data = NULL , reference = NULL , feature_spectra = NULL, reference_spectra= NULL,
                                               rt_err_thr=1, 
                                               unaccept_flag=15, accept_flag=5, suffer_flag=10,
                                               acceptable_RI = 10,
                                               n_peaks=1, acceptable_PPM_err = 10)
```

* `feature_data`: ... parameter, default value is NULL. it is a data frame contains retention time (rt) and m/z (mz) of the sample which are stored by their specific ID (Feature_ID)

* `reference`: ... parameter, default value is NULL. it is a data frame contains retention time (rt) and m/z (mz) of the compounds which are stored by the name of the compound (Name)

* `feature_spectra`: ... parameter, default value is NULL. it is extracted from MS/MS spectroscopy. it is a list of sample ID which each contains list of its m/z and Intensity for each ion

* `reference_spectra`: ... parameter, default value is NULL. it is extracted from MS/MS spectroscopy. it is a list of compounds names which each contains list of its m/z and Intensity for each ion.

* `rt_err_thr`: ...parameter, default value is 1. it is tolerance window of retention time that align sample with compound. 

* `unaccept_flag`: ...parameter, default value is 15. it is specify the unacceptable number for PPM error. the number above this will be deleted.

* `accept_flag`: ...parameter, default value is 5. it is specify a range of the acceptable number for PPM error. PPM error below 5 will tagged by "super" flag and PPM error above 5 and below 10, tagged by "acceptable" flag.

* `suffer_flag`: ...parameter, default value is 10. it is specify a lowest acceptable number for PPM error in suffer group. range of PPM error between 10 and 15 will tagged as "suffer".

* `acceptable_RI`: ...parameter, default value is 10. it is cleaning the data set both in library and sample by deleting the low intensity peaks.

* `n_peaks`: ...parameter, default value is 1. it is specify the number of the most intense peaks of ion in MS/MS data that PPM error are calculated on.

* `acceptable_PPM_err`: ...parameter, default value is 10. it is specify the lowest acceptable PPM error for the ions in MS/MS data.



## The workflow of metabolic identification 

metabolites_annotation function consists in four main steps:

a) Retention time (RT) similarity: comparison of RT of precursor in the library and in the samples.
b) Mass similarity: comparison of mass of precursor in library and sample, calculating PPM error
c) Conversion intensity to relative intensity
d) Ion mass similarity by calculating PPM error for intensive peaks for MS/MS spectroscopy 

### a)Retention time similarity

If the RT for the metabolite i in reference library is t_i and the RT for the compound j in the sample be t_j then the retention time error between a sample feature j and metabolite i in the reference library is the absolute difference between the two retention times

```{r, eval=FALSE}
RT = check_RT(feature_data = NULL , reference = NULL, rt_err_thr= rt_err_thr)
```

### b)Mass similarity by calculating PPM error

The similarity between two masses is calculated by the ppm error (parts per million) which is determining mass tolerance. The PPM error is calculated as the relative error between the mass of a feature j and mass of the reference in the library i.

According to our study goal, we delete those with bad PPM error and assign a feature to the one with good PPM error in mass status column. 

Ppm error < a – super

Ppm error < b – acceptable, may happen when ions are of low intensities

Ppm error < c – may happen when machine suffer a bit.

Ppm error > c – not good


```{r, eval=FALSE}
mass = check_mass(feature_data = NULL , reference = NULL, unaccept_flag= c, accept_flag= a, suffer_flag= b)
```


#### Merging ideal candidate in term of Retention Time and PPM error

```{r, eval=FALSE}
RT_mass = check_RT_mass (RT , mass, reference= NULL )
```

### c) Convert intensity to relative intensity: establishing new library & sample data by calculating relative intensity

Convert intensity to relative intensity and deleting the negligible relative intensity, both in library and sample spectra.
Relative intensity is calculated by dividing ion intensity to the maximum ion intensity in spectra.

```{r, eval=FALSE}
RI_lib = RI_lib_data ( reference = NULL , RT_mass, acceptable_RI = acceptable_RI)
```


```{r, eval=FALSE}
RI_sample = RI_sample_data (feature_spectra= NULL, acceptable_RI = acceptable_RI )
```


![](images/I.png) 


# Pathway analysis

margheRita implements both Over Representation Analysis (ORA) and Metabolite Set Enrichmenet Analysis (MSEA) relying on clusterProfiler and NCBI Biosystems.

## ORA

A toy example of ORA considering as input metabolite list, the metabolites belonging to the Glycolysis pathways (id=82926) and other 10 randomly selected metabolites:
```{r, eval=FALSE}
  #ORA Example
  metab_list <- unique(c(bsid2cid$CID[bsid2cid$bs_id=="82926"], sample(unique(bsid2cid$CID), 10))) #glycolysis
  res_ora <- pathway_analysis(in_list = metab_list, universe = metabolite_annotation$PubChem.CID, minGSSize = 5)
```

![ORA barplot](images/ora_barplot.jpg){width=100%}



# Data Visualization

## Boxplot

metab_boxplot function draws boxplots of metabolites/features all or metabolites of interest. 

## Heatmap

h_map function draws the heatmap of metabolites/features all or metabolites of interest.

## PCA

pca_gen function allows to draw score plot, loading plot and scree plot of PCA



