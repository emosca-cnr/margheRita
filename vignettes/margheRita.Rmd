---
title: "margheRita - an R package for analyzing the entire workflow of mass spectrometry-based metabolic profiles"
package: margheRita
output:
  rmarkdown::html_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{margheRita - an R package for analyzing the entire workflow of mass spectrometry-based metabolic profiles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r, include=F, message=FALSE, warning=FALSE, eval=T}
devtools::load_all()
```

![](images/logo.png){width=30%}


# Installation

The package can be installed using devtools:
```{r, eval=FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}
devtools::install_github("emosca-cnr/margheRita", dependencies = T)
```

To load the package:

```{r, include=TRUE, eval=FALSE}
library(margheRita)
```
 
# Input

margheRita is intended to be used after having done a number of data acquisition steps through MS-Dial [@Tsugawa2015]. It requires two inputs in text or Excel format:

- **feature data file**, which must include feature identifiers, m/z values, retention times, MS/MS spectra and feature abundances across samples;
- **sample annotation file**, which must include the following mandatory columns: "id", "injection_order", "batch", "class", "biological_rep" and "technical_rep".

# Reading input files

The function `read_input_file()` imports dataset and its relative metadata to be analyzed, as .txt,.csv or .xlsx format, creating margheRita object called "mRList". mRList is a S4 (giusto?) object contains S3 objects with information of experimental data [data], of metabolites annotation [metab_ann] QC experimental data  [QC], metadata [sample_ann]. 
Samples and QCs can be imported as unique matrix for data  or can be splitted into two: one for samples and one for QCs.
The number of the column that contain information about retention time, rt, m/z and starting data column have to be specified.


Currently margheRita includes two datasets (decidere il dataset di esempio). To load the first one, "example1", run:

```{r, eval=FALSE}
input_data_file <- system.file("extdata", "example1.xlsx", package = "margheRita")
input_metadata_file <- system.file("extdata", "example1_meta.xlsx", package = "margheRita")
mRList<-read_input_file("margheRita/example/Norm NEG/Urine_RP_NEG_norm_2batches_data.xlsx",
                        "margheRita/example/Norm NEG/Urine_RP_NEG_norm_2batches_metadata.xlsx",
                        split_QC=T, data_start_col=6, rt_col=2, mz_col=3)
```

# The margheRita object

The mRList object has this structure:

Objects in mRList  | Description
------------- | -------------
data  | matrix containing metabolite intensity
metab_ann  | metabolite annotation
sample_ann | sample annotation
QC | matrix containing metabolite intensity for QC
QC_ann | QC annotation

Importantly, the mRList can be translated into `metaboset` or `MSnSet` classes:
```{r, eval=FALSE}
mset <- as.metaboset.mRList(mRlist)
msnset <- as.MSnSet.mRList(mRlist)
```

# Pre-processing

The step of preprocessing data is crucial in order to filter missing and not accurate values. margheRita has three function for preprocessing data.

## Filtering

filter_NA function checks missing values in the experimental data.
If missing values are > 80% of the measured values, feature is trashed, otherwise missing values have to be imputed with imputation function.


```{r, eval=FALSE}
mRList_filt <- filter_NA(mRList = mRList_filt, min_metab_in_sample = 100, min_sample_with_metab = 10)
```

Imputation function provides to impute missing value of each feature replacing NA with a random number, calculated as the 10% and 25% of the minimum value of the feature. 

```{r, eval=FALSE}
mRList_imp <- imputation(mRList, seed=NULL, a=0.1, b=0.25)

```

m/z function filters features with m/z value not accurate. Values with the first decimal place comprises between 4 and 8 are excluded as they are not accurate.

```{r, eval=FALSE}
mRList_filt <- m_z_filtering(mRList = mRList, lower_quality_mass_acc = 0.4, 
                             upper_quality_mass_acc = 0.8, do_plot = T, 
                             color="black")

```

This function generates a heatscatter plot, using `LSD::heatscatter()` function exploiting **[LSD package](https://cran.r-project.org/web/packages/LSD/index.html)**. The plot is a representation of the chromatography for all samples or a specific samples if it is indicated in fuction, plotting 
$m/z$ intensity on the y-axis over the RT, retention time.


```{r, eval=FALSE}
heatscatter_chromatography(mRList, mz_limits = NULL, rt_limits = NULL, sample = NULL)
```
* `sample`: character parameter, default value is `NULL`, if specified in the plot will be provided only $m/z$ feature present in that specific sample.

* `mz_limits`: vector parameter, default value is `NULL`, that specifies the minimum and maximum value of the $m/z$ features window that have to be displayed.

* `rt_limits`: vector parameter, default value is `NULL`, that specifies the minimum and maximum value of the retention time window that have to be displayed.

![](images/hs_chrom.png){width=100%}



## Normalization

margheRita provides three ways for normalizing metabolite profiles: 

- "log", the log2 of metabolite abundances;
- "reference", every sample is divide by a reference value;
- "pqn", probabilistic quotient normalization [@Dieterle2006]; 

For "reference" and "pqn" methods, the column `reference` must be present in `mRList$metab_ann`. The function `calc_reference()` sets up such column using average metabolite values. By default, it uses the median of QC samples:

```{r, eval=FALSE}
mRList <- calc_reference(mRList)
```
```{r echo=FALSE}
head(mRList_demo$norm$metab_ann)
```
For example, here's a call to `normalize_profiles` using pqn:
```{r, eval=FALSE}
mRList_norm <- normalize_profiles(mRList, method = "pqn")
```


## Principal Component Analysis

pca_fast_VM function performs Principal Component Analysis (PCA) in different moments during the analysis. margheRita provides four different scaling, users can choose between:
-"pareto"
-"uv"
-"vector"
-"none". 
QCs  can be included or not in the analysis.
Graphical outputs are pairs plot and screeplot, number of the principal components (PCs) to visualize has to be chosen by user. Tables of loadings and scores can be saved as .csv files, specifying write_output=T, when function is launched. 
QC can be included in the analysis. After function collapse_tech_rep QCs have to be excluded from PCA.

```{r , eval=F}
mRList <- pca_fast_VM(mRList, dirout = paste0(dir_out, "/PCA_raw2"),nPcs=5,scaling="uv")
```

![Pairs of the first four components](images/Pairs.png){width=80%}




Plot2DPCA_fast has to be used after pca_fast function, it allows to plot score and loading 2D plots choosing the best couple of PCs.


```{r, eval=FALSE}
Plot2DPCA_fast(mRList, pcx=1, pcy=2, dirout = "PCA", col_by="class", include_QC=TRUE)
```


![Scoreplot of the first two components](images/Scoreplot.png){width=80% }




![Loading plot of the first two components](images/Loadingplot.png){width=80%}


## Filter by coefficient of variation

CV function calculates the coefficient of variation for each metabolite for samples and QC, separately, to assess the precision and repeatability of the measurements. 
CV is calculated, as percentage, using the following equation:

$CV=(\frac{{σ}}{{μ}})*100$

If $CV QC > CV sample$ metabolite is trashed away. 
The outputs are data frames cleaned from the features not reliable.

```{r, eval=FALSE}
mRList <- CV(mRList)

```

## Collapse technical replicates

The collapse_tech_rep function allows to return dataframe with only biological replicates.
Function calculates the mean of the technical replicates for each biological replicates for each feature. The outputs are dataframe with only biological replicates both in data and in metadata. 


```{r,eval=FALSE}
mRList <- collapse_tech_rep(mRList, remove.QC=TRUE)
```

# Univariate analysis

margheRita allows to do also statistical analysis calculating mean, median and standard deviation, fold change and univariate analysis (choosing between Student t test, U-test, kruskal-wallis and anova).

## Descriptive statistics: mean, median and standard deviation

mean_median_stdev_samples function allows to retrieve principal descriptive statistics indexes for all $m/z$ features. The function retrieves for all features across all different groups the mean, median and standard deviation. Results were reported in added columns in metab_ann.
In addition, tables can be saved as .csv files turning into true write_output, parameters.


```{r, eval=FALSE}
mRList <- mean_median_stdev_samples(mRList, write_output = F)
```

## Differential intensity analysis

Differential intensity analysis works on collapsed data, data frame has to contain only biological replicates,
hence before calculating fold change (FC) collapse_tech_rep function has to be launch.
Results were reported in metab_ann.
margheRita implements differential abundance analysis by using the fold change index: $log_2(\frac{\bar{B}}{\bar{A}})$ where $\bar{B}$ and $\bar{A}$ are the second and the first term of the specified ratio,respectively. 

Within margheRita regarding this context are implemented two functions: calculate_lfc_all, that calculates log2 FC among all useful pairwise comparisons, calculate_lfc, that calculates log2 FC indicating the couple of samples to compare.

The function calculate_lfc_all calculates log2 fold change for all $m/z$ features, among all useful pairwise comparisons. The threshold, for the upper and lower values, has to be specified in lfc_threshold, by default threshold is set at 0.25. 

```{r, eval=FALSE}
mRList <- calculate_lfc_all(mRList = mRList, lfc_threshold = 0.25)
```

If the user is interested into a specific contrast, comparing two specific groups and not all if you have more than two groups under study, calculate_lfc functions has to be used. Indeed in addition to lfc_threshold, in this function, also the names of the two groups to compare has to be specified as vector, as parameter of contrast_samples. 

```{r, eval=F}
mRList <- calculate_lfc(mRList = mRList, lfc_theshold = 0.25, contrast_samples = c("BAL_STAND", "NOD_STAND"))

```


## Check normal distribution of metabolites

norm_check function uses Shapiro-wilk's test to check the normal distribution of each metabolite. The output is a list of p-values for each feature: metabolite with a p-value<0.05 is not normally distributed, metabolite with a p-value>0.05 is normally distributed.

```{r, eval=FALSE}
mRList$shapirotest <- norm_check(mRList)

```

## Statistical tests (Student t test, Wilcoxon, Kruskal, Anova)

Univariate function allows to perform univariate analysis comparing only biological replicates, hence before starting univariate analysis collapse_tech_rep function has to be launched.
User can choose different types of statistical tests to apply: Student t-test, Wilcoxon test, anova or kruskal.

```{r, eval=FALSE}
mRList$univariate <- univariate(mRList, test_method=c( "anova"), paired=c("FALSE"), group_factor="class")
```
# Data visualization

In addition to the plots from PCA analysis, margheRita provides also boxplots and heatmaps to graph results. 

## Boxplot (R base function)

metab_boxplot function draws boxplots of the features of interest or all. Boxplots can be drawn for all the features, it takes time according to the number of features, or for only features of interest, indicated in the parameter features as vector.


```{r, eval=FALSE}
metab_boxplot(mRList, dirout="Boxplot", col_by="class", group="class")
```
 ## ggplot
 
 This function allows to draw boxplot and report p-value calculated using Student t test.

## Heatmap

h_map function draws heatmap taking all metabolites or only features of interest.

```{r, eval=FALSE}
h_map(mRList, dirout="heatmap", col_ann=NULL, col=NULL, scale_features=TRUE, features=NULL, samples=NULL, top=500)
```


# Metabolite identification

Metabolite identification in margheRita is performed by means of the function `metabolite_identification()`, which requires an mRList object and a reference library with MS and MS/MS metabolite information. The identification is possible up to level-1, provided that the required information are available in the reference library. The identification is based on the quantification of the following quantities:

- retention time (RT) error: $\epsilon_t(i) = |t(i) - t^*(i)|$;
- ppm error: $\epsilon_m(i) = \frac{|m(i) - m^*(i)|}{m^*(i)} 10^6$;
- percent relative intensity error: $\epsilon_{I_R}(i,j) = \frac{|I_R(i,j) - I^*(i,j)|}{I^*_R(i,j)} 100$.

Such quantities are used to score the similarity among precursors of features and metabolites, as well as their MS/MS spectra.

The function `select_library()` provides a means to select any of two sources:

- **margheRita**, which contains MS and MS/MS information for about 800 metabolites spanning several biological functions; these libraries provideup to level 1 identifications in positive and negative modalities for "HILIC", "LipC8", "pZIC", "RPLong" and "RPShort" chromatographic columns;

- **MS-Dial**, which covers a much larger set of metabolites ($10^5$), but is limited to level 2 identifications in positive and negative modalities.

In this example, we load the margheRita library in positive modalitity with retention times of RPShort columns and we discard all peaks with relative intensity less than 10:

```{r, eval=FALSE}
mR_library <- select_library(column = "RPShort", mode = "POS", accept_RI=10)
```

The resulting `mR_library` is a list that contains information about precursors
```{r echo=FALSE}
mRList_demo$library$lib_precursor
```
and MS/MS peaks 
```{r echo=FALSE}
mRList_demo$library$lib_peaks[1:3]
```
Once the library is selected, `metabolite_identification` will annotatate all features contained in the `mRList` given in input:
```{r, eval=FALSE}
mRList <- metabolite_identification(mRList = mRList, library_list = mR_library)
```
The function `metabolite_identification` has a series of parameters that can be adjusted to optimize the identification process (see its documentation). The resulting associations are stored in `mRList$metabolite_identification$associations`:
```{r echo=FALSE}
head(mRList_demo$norm$metabolite_identification$associations)
```
## Filtering the assocations

By default alla association that met the considered criteria are returned. When metabolite identification is applied on a large number of features (e.g., $10^3$), it's highly probale to observe many features associated with the same metabolite and the opposite, that is, a feature associated with different metabolites. This redundancy can be addressed setting `filter=TRUE`. In this case the various features associated with the same metabolite are filtered considering the best association based on the following columns: "Level", "mass_status", "peaks_found_ppm_RI" and lastly "RT_err".

## Visualization of MS/MS peaks

The spectra from all the features that match a metabolite can be inspected creating the following plots through the function `visualize_associated_spectra`,

```{r, eval=FALSE}
visualize_associated_spectra(mRList = mRList_norm_filtered, mR_library = mR_library, metabolite_id = "L508")
```


![](images/){width=80%}


# Pathway analysis

margheRita implements both Over Representation Analysis (ORA) and Metabolite Set Enrichmenet Analysis (MSEA) relying on clusterProfiler and NCBI Biosystems.

## ORA

A toy example of ORA considering as input metabolite list, the metabolites belonging to the Glycolysis pathways (id=82926) and other 10 randomly selected metabolites:
```{r, eval=FALSE}
  #ORA Example
  metab_list <- unique(c(bsid2cid$CID[bsid2cid$bs_id=="82926"], sample(unique(bsid2cid$CID), 10))) #glycolysis
  res_ora <- pathway_analysis(in_list = metab_list, universe = metabolite_annotation$PubChem.CID, minGSSize = 5)
```

![ORA barplot](images/ora_barplot.jpg){width=100%}

# References






